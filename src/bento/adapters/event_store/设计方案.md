
## 消息总线集成方案

### 1. 消息总线架构

```
正确版本
┌───────────────────────────────────────────────┐
│               Application Layer              │
│  - CommandHandlers                           │
│  - DomainEventHandlers                       │
│  - QueryHandlers                             │
│  - Ports:                                    │
│      * EventPublisherPort                    │
│      * ReadModelPort (for queries)           │
└───────────────▲──────────────────────────────┘
                │ 依赖抽象接口(Ports)
┌───────────────┴──────────────────────────────┐
│            Infrastructure Layer               │
│  ┌─────────────────────────────────────────┐  │
│  │ In-Process Bus                         │  │
│  │  - 实现 CommandBus / EventBus         │  │
│  └───────────────────▲───────────────────┘  │
│                      │                     │
│  ┌───────────────────┴───────────────────┐ │
│  │ Pulsar Event Publisher Adapter        │ │
│  │  - 订阅 in-process EventBus           │ │
│  │  - 发布领域事件到 Pulsar              │ │
│  └───────────────────▲───────────────────┘ │
│                      │                     │
│             ┌────────┴────────┐            │
│             │      Pulsar      │            │
│             └────────▲────────┘            │
│                      │                     │
│             ┌────────┴────────┐            │
│             │   ClickHouse     │            │
│             │ (Read Model DB)  │            │
│             └──────────────────┘            │
└─────────────────────────────────────────────┘

旧版本
┌─────────────────────────────────────────────────────────────┐
│                    Application Layer                        │
│  ┌─────────────┐     ┌─────────────────┐     ┌───────────┐ │
│  │  Commands   │     │  Domain Events  │     │  Queries  │ │
│  └──────┬──────┘     └────────┬────────┘     └─────┬─────┘ │
│         │                     │                     │       │
│  ┌──────▼─────────────────────▼─────────────────────▼─────┐ │
│  │                  Message Bus Layer                     │ │
│  │  ┌───────────────────┐     ┌───────────────────────┐   │ │
│  │  │   In-Process Bus  │◄────┤   Pulsar Adapter      │   │ │
│  │  └─────────┬─────────┘     └───────────┬───────────┘   │ │
│  └────────────┼───────────────────────────┼───────────────┘ │
└───────────────┼───────────────────────────┼─────────────────┘                │
                │                           │
                │                           ▼
                │                  ┌─────────────────┐
                │                  │     Pulsar      │
                │                  └────────┬────────┘
                │                           │
                │                  ┌────────▼────────┐
                └─────────────────►│   ClickHouse    │
                                   └─────────────────┘
```

### 2. 实现步骤

#### 2.1 扩展消息总线接口

```python
# src/bento/application/messaging/message_bus.py
from abc import ABC, abstractmethod
from typing import Any, Callable, TypeVar, Type, Optional
from enum import Enum

T = TypeVar('T')

class MessageBusType(Enum):
    IN_PROCESS = "inprocess"
    PULSAR = "pulsar"

class MessageBus(ABC):
    @abstractmethod
    async def publish(self, topic: str, message: Any) -> None:
        """发布消息到指定主题"""
        pass

    @abstractmethod
    async def subscribe(self,
                       topic: str,
                       handler: Callable[[Any], None],
                       message_type: Optional[Type[T]] = None) -> None:
        """订阅主题消息"""
        pass

    @abstractmethod
    async def close(self) -> None:
        """关闭消息总线"""
        pass
```

#### 2.2 实现 Pulsar 适配器

```python
# src/bento/adapters/messaging/pulsar/message_bus.py
import json
from typing import Any, Callable, Dict, Type, Optional, TypeVar
import pulsar
from pulsar.schema import Record, String, JsonSchema
from bento.application.messaging.message_bus import MessageBus

T = TypeVar('T')

class PulsarMessageBus(MessageBus):
    def __init__(self, service_url: str = "pulsar://localhost:6650"):
        self.client = pulsar.Client(service_url)
        self.consumers = []
        self.producers = {}

    async def publish(self, topic: str, message: Any) -> None:
        if topic not in self.producers:
            # 使用JSON Schema进行消息序列化
            schema = JsonSchema(type(message))
            producer = self.client.create_producer(
                topic=topic,
                schema=schema
            )
            self.producers[topic] = producer
        else:
            producer = self.producers[topic]

        producer.send(message)

    async def subscribe(self,
                       topic: str,
                       handler: Callable[[Any], None],
                       message_type: Optional[Type[T]] = None) -> None:
        # 创建消费者
        consumer = self.client.subscribe(
            topic=topic,
            subscription_name=f"sub-{topic}",
            schema=pulsar.schema.AvroSchema(message_type) if message_type else None,
            consumer_type=pulsar.ConsumerType.Shared
        )

        # 启动后台任务处理消息
        async def consume():
            while True:
                try:
                    msg = consumer.receive()
                    data = msg.value()
                    await handler(data)
                    consumer.acknowledge(msg)
                except Exception as e:
                    print(f"Error processing message: {e}")
                    consumer.negative_acknowledge(msg)

        import asyncio
        task = asyncio.create_task(consume())
        self.consumers.append((consumer, task))

    async def close(self) -> None:
        for consumer, task in self.consumers:
            consumer.close()
            task.cancel()
        for producer in self.producers.values():
            producer.close()
        self.client.close()
```

#### 2.3 集成 ClickHouse 存储

```python
# src/bento/adapters/event_store/clickhouse_event_store.py
from datetime import datetime
from typing import List, Dict, Any, Type, Optional
from clickhouse_driver import Client as ClickHouseClient

class ClickHouseEventStore:
    def __init__(self,
                 host: str = "localhost",
                 port: int = 9000,
                 database: str = "events"):
        self.client = ClickHouseClient(
            host=host,
            port=port,
            database=database
        )
        self._ensure_tables()

    def _ensure_tables(self):
        self.client.execute('''
        CREATE TABLE IF NOT EXISTS events (
            event_id String,
            event_type String,
            aggregate_id String,
            aggregate_type String,
            version UInt32,
            payload String,
            metadata String,
            timestamp DateTime DEFAULT now(),
            _ingest_time DateTime DEFAULT now()
        ) ENGINE = ReplacingMergeTree()
        ORDER BY (aggregate_type, aggregate_id, version)
        PARTITION BY toYYYYMM(timestamp)
        ''')

    async def save_events(self, events: List[Dict[str, Any]]):
        if not events:
            return

        query = '''
        INSERT INTO events (
            event_id, event_type, aggregate_id,
            aggregate_type, version, payload, metadata
        ) VALUES
        '''

        values = []
        for event in events:
            values.append((
                str(event['event_id']),
                event['event_type'],
                str(event['aggregate_id']),
                event['aggregate_type'],
                event.get('version', 1),
                event.get('payload', '{}'),
                event.get('metadata', '{}')
            ))

        self.client.execute(query, values)

    async def get_events(self,
                        aggregate_type: str,
                        aggregate_id: str,
                        from_version: int = 0) -> List[Dict[str, Any]]:
        rows = self.client.execute('''
        SELECT
            event_id, event_type, aggregate_id,
            aggregate_type, version, payload, metadata, timestamp
        FROM events
        WHERE aggregate_type = %(aggregate_type)s
        AND aggregate_id = %(aggregate_id)s
        AND version >= %(from_version)s
        ORDER BY version ASC
        ''', {
            'aggregate_type': aggregate_type,
            'aggregate_id': aggregate_id,
            'from_version': from_version
        })

        return [{
            'event_id': r[0],
            'event_type': r[1],
            'aggregate_id': r[2],
            'aggregate_type': r[3],
            'version': r[4],
            'payload': r[5],
            'metadata': r[6],
            'timestamp': r[7]
        } for r in rows]
```

#### 2.4 创建消息总线工厂

```python
# src/bento/application/messaging/factory.py
from typing import Dict, Type
from bento.application.messaging.message_bus import MessageBus, MessageBusType
from bento.adapters.messaging.inprocess.message_bus import InProcessMessageBus
from bento.adapters.messaging.pulsar.message_bus import PulsarMessageBus

class MessageBusFactory:
    _registry: Dict[str, Type[MessageBus]] = {
        MessageBusType.IN_PROCESS.value: InProcessMessageBus,
        MessageBusType.PULSAR.value: PulsarMessageBus
    }

    @classmethod
    def create(cls,
              bus_type: str = MessageBusType.IN_PROCESS.value,
              **kwargs) -> MessageBus:
        bus_class = cls._registry.get(bus_type)
        if not bus_class:
            raise ValueError(f"Unsupported message bus type: {bus_type}")
        return bus_class(**kwargs)
```

### 3. 集成到 Bento 框架

#### 3.1 配置支持

```python
# config/settings.py
from pydantic import BaseSettings, Field

class Settings(BaseSettings):
    # 消息总线配置
    MESSAGE_BUS_TYPE: str = "inprocess"  # or "pulsar"
    PULSAR_SERVICE_URL: str = "pulsar://localhost:6650"

    # ClickHouse 配置
    CLICKHOUSE_HOST: str = "localhost"
    CLICKHOUSE_PORT: int = 9000
    CLICKHOUSE_DATABASE: str = "events"

    class Config:
        env_file = ".env"
```

#### 3.2 依赖注入

```python
# src/bento/application/container.py
from dependency_injector import containers, providers
from config.settings import Settings
from bento.application.messaging.factory import MessageBusFactory
from bento.adapters.event_store.clickhouse_event_store import ClickHouseEventStore

class Container(containers.DeclarativeContainer):
    config = providers.Configuration()

    # 消息总线
    message_bus = providers.Singleton(
        MessageBusFactory.create,
        bus_type=config.MESSAGE_BUS_TYPE,
        service_url=config.PULSAR_SERVICE_URL
    )

    # 事件存储
    event_store = providers.Singleton(
        ClickHouseEventStore,
        host=config.CLICKHOUSE_HOST,
        port=config.CLICKHOUSE_PORT,
        database=config.CLICKHOUSE_DATABASE
    )
```

### 4. 使用示例

#### 4.1 发布领域事件

```python
# 在领域服务或应用服务中
from bento.application.container import container

async def ship_order(order_id: str):
    # 1. 执行业务逻辑
    order = await order_repository.get(order_id)
    order.ship()

    # 2. 发布领域事件
    event = OrderShippedEvent(
        order_id=order.id,
        tracking_number="TRK123456",
        shipped_at=datetime.utcnow()
    )

    # 发布到消息总线
    bus = container.message_bus()
    await bus.publish("order_events", event.dict())

    # 保存到事件存储
    event_store = container.event_store()
    await event_store.save_events([{
        'event_id': str(uuid.uuid4()),
        'event_type': 'order_shipped',
        'aggregate_id': str(order.id),
        'aggregate_type': 'order',
        'version': order.version,
        'payload': event.dict(),
        'metadata': {
            'user_id': 'system',
            'timestamp': datetime.utcnow().isoformat()
        }
    }])
```

#### 4.2 订阅处理事件

```python
# 在后台处理器中
from bento.application.container import container

async def process_order_events():
    bus = container.message_bus()

    async def handle_event(event: dict):
        # 处理订单事件
        if event['event_type'] == 'order_shipped':
            await send_shipping_notification(
                order_id=event['payload']['order_id'],
                tracking_number=event['payload']['tracking_number']
            )

    # 订阅主题
    await bus.subscribe("order_events", handle_event)
```

### 5. 部署与扩展

#### 5.1 使用 Docker Compose 部署

```yaml
# docker-compose.yml
version: '3.8'

services:
  pulsar:
    image: apachepulsar/pulsar:latest
    ports:
      - "6650:6650"
      - "8080:8080"
    command: >
      bin/pulsar standalone

  clickhouse:
    image: clickhouse/clickhouse-server:latest
    ports:
      - "9000:9000"
    volumes:
      - clickhouse_data:/var/lib/clickhouse
    environment:
      CLICKHOUSE_DB: events

volumes:
  clickhouse_data:
```

#### 5.2 监控与运维

1. **Pulsar 监控**:
   - 使用 Pulsar Manager (http://localhost:9527)
   - 监控主题积压和消费延迟

2. **ClickHouse 优化**:
   - 根据查询模式调整分区键
   - 使用物化视图预聚合常用查询

3. **应用指标**:
   - 暴露 Prometheus 指标
   - 设置 Grafana 仪表板

### 6. 性能考虑

1. **批量处理**:
   - 实现批量发布和消费
   - 使用 Pulsar 的批处理特性

2. **并行处理**:
   - 使用 Pulsar 的共享订阅模式
   - 实现工作池处理消息

3. **错误处理**:
   - 实现死信队列
   - 添加重试机制

这种架构结合了 Pulsar 的高吞吐量消息传递、内存总线的低延迟处理以及 ClickHouse 的强大分析能力，同时保持了与 Bento 框架的无缝集成。
